## just lose it 各个功能模块思路

### Net网络部分

#### netty使用
主要编写了基于socket得Tcp服务端和客户端、还有webSocket的服务端和客户端。

服务端主要是在netty的信息流的处理channel中增加了 链接状态处理器、protobuf包处理器、路由规则处理器


#### 包解析
包结构：头部：通信包总长度(int)+协议包id长度(int)+信号包长度(int)+协议包byte+（信号包byte）
使用baidu开源的jproto来进行解析

协议包：请求响应的内容 协议包的读出：先读取header 然后剩下内容减去信号包的长度即可
信号包：用于实现Rpc
#### 路由分发规则
分成两部分：无信号包 有信号包
##### 无信号包：
根据session中的uid（玩家id）分发到不同的线程进行处理。
##### 有信号包：
目前信号包有两种： ：
SignalAttachment：用于远程Rpc服务，其中有根据参数client的不同又分为不同的Rpc服务
1、client=0   代表着是服务提供者已经对该包处理完了，接着只需要根据该信号包找出对应的future即可完成异步调用
2、client=1  代表着有参数来指定要在服务提供者的特定线程处理。 对该特殊参数取模分发到特定线程处理
3、client=2   代表着默认逻辑来指定线程处理
4、client=12  代表着是外部的客户端的信息，不需要做任何处理，直接按照无信号包逻辑处理
GateWayAttachment：用于网关分发游戏包
网关包的client参数是布尔类型
true表示：是客户端发送的，逻辑服收到该请求后则需要设置成false,然后处理逻辑
false表示：是别的服务提供者发送给网关的，网关可以再次做特殊处理逻辑
#### 协议注册
配置文件里面填写：协议包包名，模块包包名
服务启动的时候 扫描协议包里的所有协议， 扫描模块包里面模块号下对对应的协议号。将其与协议号和协议包一一对应

使用也很简单 只需要定义模块包类   协议类 用jproto注解定义
然后定义controller类，方法使用@packetResiver注解标识即可

#### 网关gateway
主要用于分发协议和与游戏客户端保持链接
网关分发逻辑：
根据用户userId来获取服务器Sid 然后根据链接上网关的服务提供者的服务器sid来选择分发到哪个逻辑服执行
#### 远程服务Rpc
如何实现远程Rpc？

拆分为：服务的发现 请求负债均衡 & Rpc协议数据的返回
服务请求的路由：游戏的话一般不需要负载均衡：所以目前我编写的有两个基础的负载均衡器：
一个是随机，随机在服务提供者中寻找
一个是一致性哈希负载均衡，将节点变化的影响降到最少
用的最多的还是： 根据用户id得到服务器id然后指定到对应逻辑服

普通没有回调的Rpc方法，等同于将协议包发送到远程服务器，远程服务器处理完即可

有回调的Rpc方法，则在上述基础上等待远程服务器处理完返回数据包再处理回调数据。这里用到的核心点就是CompletableFuture

核心思想是客户端再发送远程rpc请求的时候，本地缓存rpc请求及其唯一标识，等待该请求在远程服务器处理完之后
根据其唯一标识找到其rpc请求对于后续处理逻辑的回调就行执行即可。


##### AsyncRpc syncRpc
如果需要同步，则很简单CompletableFuture.get(),等待回调完成的comple

异步则需要调用则很简单CompletableFuture.whenCompleteAsync(),指定异步回来在什么线程池执行

#### 注册中心&消费者&服务者模型
注册中心：采用的是zookeeper
整体思路： 
作为服务器，被客户端连接的Session:  
作为为客户端，连接服务提供者后的Session:

每个服务器的配置都得填写 自己提供的服务和自己消费的服务（需填写分发器类型）
每个服务启动的时候，如果自己有提供的服务，就启动一个TcpServer负责提供服务。
然后连接zookeeper，将自己提供服务的模块号-服务器信息等组合成一个字符串 注册到zookeeper上

然后如果有需要消费的服务，则根据配置的分发器类型，以模块id->分发器存储起来。遍历zookeeper的节点
根据消费的模块来获取提供该模块的所有服务的特殊字符串，然后对每个服务提供者建立链接TcpServer


订阅zookeeper每个节点的变化，及时对于服务提供者列表进行更新。对于故障点进行摘除



### orm数据存储模块
#### accessor db层  抽象出增删改查的接口，后面可以对于不同的数据库进行不同的实现
#### Persister 持久化层 主要定义持久化的逻辑。 cron表达式定时的入库规则  Time每隔一段时入库
#### cache 缓存层 每个实体类都有一个自己的缓存池 服务启动完毕 对于@EntityCacheAutowired的变量IEntityCache实现注入



### 定时器模块
每一秒tick一次判断时间是否过期执行任务。

### 事件模块

通过自定义注解的方式，根据事件的类型找出其要触发的方法，再用javasssit创建好触发方法的增强类，以事件类型为key存储起来。后续直接调用。



