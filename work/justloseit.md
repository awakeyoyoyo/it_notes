## just lose it 各个功能模块思路

### Net网络部分

#### netty使用

主要编写了基于socket得Tcp服务端和客户端、还有webSocket的服务端和客户端。

服务端主要是在netty的信息流的处理channel中增加了 链接状态处理器、protobuf包处理器、路由规则处理器

#### 包解析

包结构：头部：通信包总长度(int)+协议包id长度(int)+信号包长度(int)+协议包byte+（信号包byte）
使用baidu开源的jproto来进行解析

协议包：请求响应的内容 协议包的读出：先读取header 然后剩下内容减去信号包的长度即可
信号包：用于实现Rpc

#### 路由分发规则

分成两部分：无信号包 有信号包

##### 无信号包：

根据session中的uid（玩家id）分发到不同的线程进行处理。

##### 有信号包：

目前信号包有两种： ：
SignalAttachment：用于远程Rpc服务，其中有根据参数client的不同又分为不同的Rpc服务
1、client=0   代表着是服务提供者已经对该包处理完了，接着只需要根据该信号包找出对应的future即可完成异步调用
2、client=1  代表着有参数来指定要在服务提供者的特定线程处理。 对该特殊参数取模分发到特定线程处理
3、client=2   代表着默认逻辑来指定线程处理
4、client=12  代表着是外部的客户端的信息，不需要做任何处理，直接按照无信号包逻辑处理
GateWayAttachment：用于网关分发游戏包
网关包的client参数是布尔类型
true表示：是客户端发送的，逻辑服收到该请求后则需要设置成false,然后处理逻辑
false表示：是别的服务提供者发送给网关的，网关可以再次做特殊处理逻辑

#### 协议注册

配置文件里面填写：协议包包名，模块包包名
服务启动的时候 扫描协议包里的所有协议， 扫描模块包里面模块号下对对应的协议号。将其与协议号和协议包一一对应

使用也很简单 只需要定义模块包类   协议类 用jproto注解定义
然后定义controller类，方法使用@packetResiver注解标识即可

#### 网关gateway

主要用于分发协议和与游戏客户端保持链接
网关分发逻辑：
根据用户userId来获取服务器Sid 然后根据链接上网关的服务提供者的服务器sid来选择分发到哪个逻辑服执行

#### 远程服务Rpc

如何实现远程Rpc？

拆分为：服务的发现 请求负债均衡 & Rpc协议数据的返回
服务请求的路由：游戏的话一般不需要负载均衡：所以目前我编写的有两个基础的负载均衡器：
一个是随机，随机在服务提供者中寻找
一个是一致性哈希负载均衡，将节点变化的影响降到最少
用的最多的还是： 根据用户id得到服务器id然后指定到对应逻辑服

普通没有回调的Rpc方法，等同于将协议包发送到远程服务器，远程服务器处理完即可

有回调的Rpc方法，则在上述基础上等待远程服务器处理完返回数据包再处理回调数据。这里用到的核心点就是CompletableFuture

核心思想是客户端再发送远程rpc请求的时候，本地缓存rpc请求及其唯一标识，等待该请求在远程服务器处理完之后
根据其唯一标识找到其rpc请求对于后续处理逻辑的回调就行执行即可。

##### AsyncRpc syncRpc

如果需要同步，则很简单CompletableFuture.get(),等待回调完成的comple

异步则需要调用则很简单CompletableFuture.whenCompleteAsync(),指定异步回来在什么线程池执行

#### 注册中心&消费者&服务者模型

注册中心：采用的是zookeeper
整体思路： 
作为服务器，被客户端连接的Session:  
作为为客户端，连接服务提供者后的Session:

每个服务器的配置都得填写 自己提供的服务和自己消费的服务（需填写分发器类型）
每个服务启动的时候，如果自己有提供的服务，就启动一个TcpServer负责提供服务。
然后连接zookeeper，将自己提供服务的模块号-服务器信息等组合成一个字符串 注册到zookeeper上

然后如果有需要消费的服务，则根据配置的分发器类型，以模块id->分发器存储起来。遍历zookeeper的节点
根据消费的模块来获取提供该模块的所有服务的特殊字符串，然后对每个服务提供者建立链接TcpServer

订阅zookeeper每个节点的变化，及时对于服务提供者列表进行更新。对于故障点进行摘除

### GRPC


消费者：

> 配置消费的服务以及对应信息，构建channel。 后续各模块Rpc消费获取该channel手写初始化Stub即可

服务提供者：

> 配置提供服务端口，服务信息。构建GrpcServer将服务注册进去

### orm数据存储模块
{持久化、缓存、映射实体类}
持久化：支持定时入库 两种方案：异步线程定时入库（需要备份对象副本）   玩家线程定时入库（可能会阻塞玩家线程）
缓存：框架方面支持自定义缓存过期时间，LRU， 在项目层面可以增加离线移除缓存
映射实体类：利用mongodb driver来创建表 形成映射关系

自定义缓存注解Cache，对于使用了该注解的成员变量注入缓存对象。

缓存池对象（不同的对象，不同的缓存策略）->持久化器（不同的持久化策略）

生命周期：起服扫描所有实体类->构建缓存池&持久化器->spring容器初始化完毕后注入缓存池



### scheduler定时器模块

每一秒tick一次判断时间是否过期执行任务。

### 事件模块

通过自定义注解的方式，根据事件的类型找出其要触发的方法，再用javasssit创建好触发方法的增强类，以事件类型为key存储起来。后续直接调用。


### hotswap热更模块




### 优雅使用|或运算

```JAVA
int  Read =1,    //0001
int   Write =2,   //0010
int  Execute =4  //0100
```
通过|运算可以继承Read、Write的权限， 0011=3    
```int combinedPermission = Read | Write;```

上诉组合了权限集合，那么进行判断可以用与运算
```java
if(combinedPermission & Read){
    //拥有改权限
}
```
