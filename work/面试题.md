[toc]
### java基础

对象编程的三大特性之一（封装、继承、多态）
封装：
继承：
多态：

##### java线程池的参数

##### 单例设计



### Redis

##### 1.Redis的基础数据结构类型有？

> String：字符串类型，特点是二进制安全，可以存放序列化后的各种对象
>
> set：不可重复的集合
>
> Zset：有序的集合，通过分数来进行排序
>
> hash：存放key value
>
> List：简单的队列
>
> - 对于string 数据类型，因为string 类型是**二进制安全**的，可以用来存放图片，视频等内容，另外由于Redis的高性能读写功能，而string类型的value也可以是数字，可以用作**计数器**（INCR,DECR），比如分布式环境中统计系统的在线人数，秒杀等。
>
> -  对于 hash 数据类型，value 存放的是键值对，比如可以做**单点登录存放用户信息**。
>
> - 对于 list 数据类型，可以实现简单的消息队列，另外可以利用lrange命令，做基于redis的分页功能
> - 对于 set 数据类型，由于底层是字典实现的，查找元素特别快，另外set 数据类型不允许重复，利用这两个特性我们可以进行全局去重，比如在用户注册模块，判**断用户名是否注册**；另外就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。
> - 对于 zset 数据类型，有序的集合，可以做范围查找，**排行榜应用，取 TOP N 操作**等。


redis的基本数据结构  队列list 集合set 有序集合Zset  map string
##### 2.说一下Redis的两种持久化方式？

> Redis的持久化方式重要有两种，分别是RDB和AOF两种，
>
> RDB的就是存储当前数据的快照，后面恢复数据直接恢复到存储的快照版本。
>
> AOF就是存储增删的操作，后门恢复数据就是将所有的操作语句重新执行。

##### 3、redis的集群和哨兵机制和主从机制

首先redis的集群有三种方式：哨兵模式、主从模式、cluster模式

- 主从机制

> 将多个redis实例分为一个Master主节点，多个从机Slave节点。
>
> Master主机负责解决写操作，Slave从机只负责读，将读写操作分离

- 哨兵机制--基于主从机制

> 哨兵模式作用：在主节点挂掉之后，从节点能够自动变成主节点，避免无法进行写操作的情况。

- cluster模式（分布式存储）

> Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N
>
> 然后通过哈希槽方式来访问redis，每个redis都有固定的槽位，集群中用相同的算法了求出key对应的槽位进而选择对应的redis访问

### Spring

##### 1.说一下Spring？

> spring是一个java的基础框架，它的特点主要是两个方面IOC和AOP，首先IOC是控制反转的意思，在Spring中是通过IOC容器来管理对象之间的依赖和生命周期的，而AOP就是通过动态代理来增加方法，抽取公共的逻辑代码，主要实现是通过spring的BeanPostProcessor来实现。

##### 2.IOC容器的理解？

> 用于管理对象之间的依赖和生命周期的容器，依赖注入：将java对象由创建者进行管理改为由IOC容器进行管理。

##### 3.AOP的理解？

> 通过动态代理来增强方法的实现，可以抽取公共的逻辑出来：常见的使用有日志打印等，主要实现是通过spring的BeanPostProcessor来实现。

##### 4.容器启动的过程？

> （1） 通过BeanDefinitionReader下的子类，不同子类有不同的读取方式，如xml、注解的形式，读取将来会用到的Bean来生成对应的BeanDefinition信息
>
> （2）**设置容器的配置信息**，设置容器的awake接口会生效
>
> （3）**执行注册的BeanFactoryPostProcessor接口中的方法**，要用于对读取后的BeanDefinition来进行处理，我们可以定制自己的处理器来插手容器的创建过程，PlaceHolderBeanFactoryPostProcessor处理配置文件中占位符问题
>
> （4）注册处理bean生命周期的BeanPostProcessor 
>
> （5）注册事件监听器等
>
> （6）容器的初始化完成，然后初始化非懒加载且单例的Bean

##### 5.bean的生命周期？

> （1）首先Bean被依赖，Spring容器中又没有此时就触发了Bean的初始化
>
> （2）根据反射生成一个Bean的对象
>
> （3）然后根据BeanDefinition来初始化Bean的属性
>
> （4）根据Bean所实现的Aware接口来注入对应属性 常见：上下文
>
> （5）执行BeanPostProcessor的before方法
>
> （6）执行Bean配置的的init方法
>
> （7）执行BeanPostProcessor的After方法 
>
> （8）得到完整的Bean对象放入容器中

##### 6.循环引用问题？

> A对象的成员变量有B，B的成员变量中有A。这样就会产生循环引用，Spring中通过三级缓存的方式来解决循环引用，其中一级缓存：存储的是已经完整的对象，二级缓存中存储的是实例化好的对象，三级缓存中存储的是构建对象的lambda表达式（用于方便构建代理对象）。构建代理对象需要依赖真的对象，那么className就会对应代理对象和真的对象，造成混乱，所以需要三级缓存。
>
> 无法解决在构造器下的循环依赖

### Springboot

##### 1.什么是 Spring Boot?

> Springboot在我的理解上是一个框架的框架，它可以帮助我们轻松的整合我们需要使用的框架的依赖，例如就是构建好一些常用框架的starter，我们只需要引入该依赖就可使用该框架功能，可以帮助我们减少使用xml文件来注入bean，默认就有自动配置类来注入bean，并且约定好再application配置文件中可以配置常见的框架的使用的变量值。还整合了servlet容器tmocat可以直接运行。

##### 2.SpringBoot的核心注解有哪些及其作用？

##### 3.Springboot自动配置的流程

（1）**@EnableAutoConfiguration**  由多个注解组成

（2）**@Import(AutoConf igurationImportSelector.class)**会每个依赖包从META-INF/spring.factories位置的加载spring.factories文件。

（3）然后springboot-autoconfigure中的spring.factories配置了一大堆容器所要加载的配置类	XXXAutoConfiguration

（4）XXXAutoConfiguration就是每个组件注入的配置类了 

### Java基础

##### 1.StringBuilder和StringBuffer哪个是线程安全？

> StringBuilder线程安全。

##### 2.HashMap和HashTable的区别？

> 首先两者的底层实现都是数组+链表的数据结构实现的，数组用于hash处理，链表用于解决hash冲突，但如果达到某些条件的话链表会自动转换成红黑树，提高查询速度。
>
> 最大的区别是HashMap是线程不安全的，HashTable是线程安全的，HashTable底层在一些会造成并发安全的操作上都进行了上锁操作，而且一锁就是整个容器锁住，建议使用ConcurrentHashMap，ConcurrentHashMap底层采用了分段锁的技术，锁的粒度减少了，性能会比较好。

##### 3.HashMap为什么是线程不安全的？

> 多个线程同时插入相同key的value时，就会有线程安全问题，本质上就是一个不同线程同时修改一个对象的问题。会出现覆盖的问题。

##### 4.线程的生命周期？

> 线程的[生命周期](https://so.csdn.net/so/search?q=生命周期&spm=1001.2101.3001.7020)包含5个阶段，包括：
>
> **新建:**线程刚被创建出来后
>
> **就绪**:就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段。
>
> **运行:**获得了CPU资源执行对应的代码的状态
>
> **阻塞:**在运行状态的时候
>
> - 调用了wait（） 需要上锁，并且调用notify来唤醒
> - 调用了sleep（） 需要等待时间结束
> - 等待IO流的输入输出
>
> **死亡**:代码执行完毕，抛出异常。


新建状态
就绪状态 调用了start()
运行状态
等待状态  sleep()
阻塞状态  wait()

##### 5.线程池的作用？

> 线程池是比较宝贵的资源，不适宜频繁的创建和销毁，线程池的作用就是管理好线程的生命周期，当需要使用到的时候就到线程池中去拿，不需要自己额外的创建线程，将底层策略交给线程池。
>
> 提一下项目的线程池模型。  类似于Redis的分片 保证了每次的操作都是去对应的线程执行

##### 6.三大类型线程池？

> Executors.newSingleThreadExecutor() //单个线程的线程池
>
> Executors.newFixedThreadPool(100) //固定大小的线程池
>
> Executors.newCachedThreadPool() // 可伸缩的线程池

##### 7.七大参数？

> - corePoolSize, //核心线程池大小
> - maximumPoolSize,    //最大核心线程池大小
> - keepAliveTime,     //超时了没有人调用就会释放
> - TimeUnit unit,          //超时单位
> - BlockingQueue<Runnable> workQueue, //阻塞队列
> - ThreadFactory threadFactory,       //线程工厂，创建线程的，一般不动
> - RejectedExecutionHandler handler)  //拒绝策略

```java
//本质开启线程池调用了ThreadPoolExecutor()
    public ThreadPoolExecutor(int corePoolSize, //核心线程池大小
                              int maximumPoolSize,    //最大核心线程池大小
                              long keepAliveTime,     //超时了没有人调用就会释放
                              TimeUnit unit,          //超时单位
                              BlockingQueue<Runnable> workQueue, //阻塞队列
                              ThreadFactory threadFactory,       //线程工厂，创建线程的，一般不动用
                              RejectedExecutionHandler handler) { //拒绝策略
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

##### 8.四种拒绝策略？

没有空闲的线程，且任务队列已经满了

> - new ThreadPoolExecutor.AbortPolicy() //线程满了还有任务要进入则,不做处理,直接抛出异常
> - new ThreadPoolExecutor.CallerRunsPolicy() //由调用线程执行对应的任务
> - new ThreadPoolExecutor.DiscardPolicy() //队列满了丢掉任务,不进行处理，不会抛出异常!
> - new ThreadPoolExecutor.DiscardOldestPolicy() //队列满了，丢弃队列中第一个任务，重新提交任务

##### 9. 线程池池的最大的线程如何去设置? 

了解:IO密集型与CPU密集型

> IO密集型：  例如处理网络IO，IO输入输出，   2*N+1
>
> CPU密集型： 线程执行基本不会进入阻塞状态的，N+1

##### 10.什么是JUC

> Java Util concurrent 三个处理线程安全问题的包

##### 11.并发和并行的区别？

> 并发：多个线程共同操作同一个资源
>
> 并行：多个CPU或者是多个线程同时执行

##### 12.Lock锁和Synchronized锁的区别

> synchronized是内置的java关键字而Lock是一个接口
> synchronized无法判断获取锁的状态,Lock可以判断是否获取到了锁
> synchronized会自动释放锁,Lock必须要手动释放锁！否则会造成死锁.
> synchronized 线程1(获得锁,阻塞),线程2(等待,傻傻的等);Lock锁就不会一直等下去
> synchronized 可重入锁 不可以中断的 非公平,Lock 可重入锁 可以判断的 非公平(可以设置)
> synchronized 适合锁少量同步代码,Lock适合锁大量同步代码.

##### 13.CountDownLatch类?

> 主要用于某一个线程等待其他线程执行完毕后再执行的累，当数量变为0之后就会唤醒主线程继续执行。
>
> 原理:当每次有线程调用 countDown()方法则数量减一,假设数量变为0，await()方法就会被唤醒继续执行！

##### 14.四大函数式接口(必须掌握)

> lambda表达式，链式编程，函数式接口，Stream流式计算

函数式接口：只有一个方法的借口

##### 15.Future 异步回调？

> Futrue我的理解就是对于未来的某个执行结果进行操作，而且future的对于未来的结果的处理是默认是在当前现场执行的。

##### 16.ArraList和LinkList的区别?

底层是数组  查询多的建议用arry  初始化需要申请一篇数组空间，会有空间浪费 随着数据量越大数组扩容会越明显

底层是链表  增删除多的建议linkList
> 首先是底层的数据结构不同，ArrayList的底层实现是数组，LinkList的底层实现是链表，然后由于数据结构的不同呢，ArrayList的访问单个元素的速度是比链表快的，可以直接通过下标的形式来访问，但是ArrayList会存在内存浪费的情况，因为数组的话需要事先申请空间且是根据阈值来进行扩容，所以申请空间的大小不等于所有元素的大小。而如果是频繁的插入的话使用LinkList会比较好，因为是链表的形式，只需要改变指针的方向即可，而数组的插入会讲后续的元素都后移一位。 然后遍历速度在大数据量的情况下是数组比较快，因为空间是连续的，不需要每次都读取下一个元素的地址，可以直接计算出来。

##### 17.给出一个父子类，里面有各种实例变量，静态变量，静态代码块，实例代码块，里面有打印语句，然后要求说说各个打印顺序

##### 18.二维数组，分别从行遍历和列遍历，哪个快？
   行遍历比较块，因为行的话是是一整个数组，这个数组的空间是连续的，遍历起来会更快，我列遍历是先遍历数组找到 行数组的指针 再去找对应数据
##### 19.A<? etends E> , A<? super E> 的区别
   extends是代表A这个类是E子类   super代表A这个类是父类
> extends：表明该A类是E的子类
>
> super：表示A类是只能是E的负累

##### 20. AQS，ComccurentHashMap,CAS?
Abstract Queued Synchronizer 抽象队列锁！ 悲观锁
AQS：核心就是用一个int变量来表示锁的状态，并且用一个先进先出的队列来控制阻塞队列，实现锁的机制
compare and set 检查后再交换  乐观锁
CAS：比较再交换，即每次都获取最新的值，然后计算，然后再设置回去的时候再比较与获取的值是否相同，相同才设置。java底层保证了最后一步的获取比较设置是原子性。

##### 21.Enum<E extends Enum > 是什么？

这样子是为了让class参数化，并且限制了Class的类型，我们在该类中的方法中返回对象的时候，可以返回子类对象类型。

##### 22.java序列化与反序列化？
Java序列化是指把Java对象转换为字节序列的过程；而Java反序列化是指把字节序列恢复为Java对象的过程。
如果使用java原生的序列化工具，则被序列化的类必须实现Serializable接口，否则会报错，transient关键字标识的成员则不会被序列化，
序列化id在反序列化的时候会用到 反序列化会根据读取的文件中的序列化id是否跟.class文件中的序列化id是否相等
##### 4.Thread.sleep()和Object.wait()调用时线程处于什么状态？

Thread.sleep() 线程处于睡眠状态，如果此时线程获取了锁，则不会主动的放弃锁
Object.wait() 线程进去了阻塞状态，如果线程获取了锁，会把Object的锁进行释放再进入阻塞状态，等待object.await()唤醒
### JVM
堆：存储java对象
栈：方法调用栈的数据接口
虚拟机栈：jvm方法调用栈
程序计数器：存储指令执行的编号
方法区：存储类对象以及常量的地方



##### 1.说一下JVM的内存分布?

> 堆：存储对象的地方
>
> 栈：存储方法执行的数据结构
>
> 虚拟机栈：存储本地方法执行的数据结构
>
> 程序计数器：存储指令的执行编号
>
> 方法区：存储类对象以及常量的地方

##### 说一下垃圾回收

java的垃圾回收主要是对于 堆区域的对象进行回收。而堆区域又分为两个区域：新生代和老年代 对于不同的区域采用的垃圾回收算法又是不一样的。垃圾回收方法主要又标记清楚、标记清楚整理、复制三种
标记清楚是根据可达性分析算法，标记出死去的对象然后清楚。主要用于老年代，
标记清楚整理：则在上述基础上加多了整理内存空间的操作，主要用于新生代区（因为此区域的对象回收的概率大，可能会照成内存区域不规则）
复制算法：将内存分为三块，一块大内存，两块小内存，根据算法查找出 大内存和旧的小内存中存活的变量，复制到新的小内存中， 大内存和旧的小内存清除。

可达性算法：是用来分析对象是否存活的算法。主要是规定好root对象，然后对于与root对象有引用链关系的对象标记成是存活的，没有引用链关系的对象就标示为死亡对象。
其中root对象有：栈中的方法里面的引用、虚拟机栈中的引用、方法区中常量的引用、类静态属性的引用
##### 2.说一下垃圾回收算法?

首先垃圾回收算法主要有 标记清除、标记清除整理、复制三种。标记清除就是根据可达性分析算法，标记出已经死去的对象，然后清除。主要用于老年代。

复制算法：讲内存分为三块，一块大内存：survier 两块同等大小的小内存区域：eden。根据可达性分析算法，标记出survier和旧eden中存活的对象然后复制到新eden中，然后清空survier和旧eden。

可达性算法：主要是规定好root对象，然后对于与root对象有引用链关系的对象标记成是存活的，没有引用链关系的对象就标示为死亡对象。其中root对象有：栈中的方法里面的引用、虚拟机栈中的引用、方法区中常量的引用、类金泰属性的引用

##### 3.说一下类加载的过程？

当程序主动使用某个类的时候，如果该类还没被加载到内存中，那么就会触发类的加载。

过程是

1、加载：根据类名将class文件加载到内存中，在堆中创建java类对象，指向方法区中类的数据

2、链接 ：校验类的正确性，解析引用，将static final修饰的变量都会在clinit放啊放中。

3、初始化：开始执行类定义的java的程序代码<clinit>()方法，并且加载一个类的时候会先加载其父类，所以会先执行父类的clinit方法 static包裹的代码块和


（1）加载，加载类的二进制流 生成该类的class对象
（2）验证：验证class文件的安全性
（3）准别：为类的静态变量 常量分配内存并且初始化未默认值
（4）解析：将类的里面的符号引用替换成直接引用
（5）初始化：执行静态代码和静态变量的赋值。如果有父类会，会先加载其父类，所以会先执行父类静态代码和静态变量的赋值

1、加载

> - 通过一个类的全限定名获取该类的二进制流。
> - 将该二进制流中的静态存储结构转化为方法去运行时数据结构。
> - 在内存中生成该类的Class对象，作为该类的数据访问入口。

2、验证

> 检验class文件的安全性

3、准备

> 是为类的静态变量分配内存并将其初始化为默认值，

4、解析

> 将类里面的符号引用替换成直接引用

5、初始化

> 开始执行类定义的java的程序代码<clinit>()方法，并且加载一个类的时候会先加载其父类，所以会先执行父类的clinit方法 static包裹的代码块和

6、使用

7、卸载



类加载器：主要就是负责将类加载到内存中，

有三种类加载器：

- 启动类加载器（bootstrap）：加载Java的核心库  \lib

- 拓展类加载器（extension）：加载依赖jar包    \lib\ext

- 应用类加载器（application）：加载项目代码的   \classPath

还可以自定义类加载器继承[抽象类](https://so.csdn.net/so/search?q=抽象类&spm=1001.2101.3001.7020)java . lang.ClassLoader类，修改其loadClass方法。

类加载器的特点：

**1.全盘负责**：当一个类加载器加载一个类时，该类所依赖的其他类也会被这个类加载器加载到内存中。
**2.缓存机制**：所有的Class对象都会被缓存，当程序需要使用某个Class时，类加载器先从缓存中查找，找不到，才从class文件中读取数据，转化成Class对象，存入缓存中。

**3.双亲委派机制**：即把请求交由父类处理,它是一种任务委派模式。父类无法处理才到子类进行处理。避免类的重复加载

在JVM中,即使这两个类对象(class对象)来源同一个Class文件,被同一个虚拟机所加载,但只要加载它们的ClassLoader实例对象不同,那么这两个类对象也是不相等的。

##### 4.如何实现热更？

1、需要编写属于自己的classLoader，因为默认的应用类classLoader会缓存已经加载的class，不会重新加载。并且热更需要移除旧的类，我们只需要把旧的classLoader移除即可。

修改双亲委托机制 跳过应用类加载器。

2、监听class文件的变化，然后调用Class.forName来主动的用自己的classLoader来加载新的类

3、class的卸载，将就的classLoader置空等待gc回收

### 数据库

##### 1.事务的四大特征？

> 原子性：事务中的操作要么全部执行，要么全部不执行
>
> 隔离性：事务和事务之间是隔离开的. 一个事务看不到另一个事务正在操作的数据，互不影响
>
> 一致性：事务操作前后，保证数据从一个正确的状态到另一个正确的状状态
>
> 持久性： 一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中

##### 2.MYSQL的索引什么时候失效？

- 条件中有or，即使其中有条件带索引也不会使用；
- 对于多列索引，不使用的第一部分，则不会使用索引；
- like查询以%开头，索引无效；
- 当字段类型为字符串时，条件中数据没有使用引号引用。
- 避免在 where 子句中对字段进行 null 值判断

##### 3、建立索引需要注意什么？

- 经常需要作为条件来查询的列
- 有顺序且经常需要范围查询的列
- 不要在有大量相同取值的字段建立索引
- 经常修改的字段不建立索引





##### 3.关系型数据库和非关系型数据库之间的区别？

> 关系型数据库就是有固定的表结构，但是基本是存储在硬盘上
>
> 非关系型数据库就是存储格式是key value的形式，可以存放在内存中

##### 5.Mysql的隔离级别

- 读未提交

  > 事务中的修改，即使未提交，对于其他事务也是可见的。

- 读已提交

  > 一个事务只能读取已经提交的事务所做的修改，即使一个事务所做的修改在提交之前对于其他事务都是不可见的。

- 可重复读

  > 保证在同一个事务中多次读取同一数据的结果是一样的

- 串行化

  > 强制事务串行执行，这样多个事务互不干扰。读的时候加共享锁，也就是其他事务可以并发读，但是不能写。写的时候加排它锁，其他事务不能并发写也不能并发读。

### 网络层

##### 1.说一下网络分为哪五层？

- 应用层：http协议
- 传输层：TCP和UDP
- 网络层：IP
- 链路层：MAC地址
- 物理层

##### 2.TCP和UDP的区别？

> TCP是面向连接的协议，是可靠传输，是面向字节流的，应用层的数据会先传输到TCP缓存区再由TCP协议来发送报文
>
> UDP是面向报文传输的，无需建立连接，没有连接状态，应用层发送的报文多大就传输多大。

##### 3.TCP三次握手？

- 第一次握手，客户端把自身的序号携带上发给服务端
- 第二次握手，服务端收到第一次握手报文，纪录下客户端的序号，返回响应，并且携带上自身的序号
- 第三次握手，客户端收到了服务端的响应报文，记下服务端的序号，然后握手完成可以开始传输数据

##### 4.TCP为什么不两次握手？ 为什么不四次握手？

- 首先TCP协议在传输层

- 为什么不是两次？

  需要确认同步双方的初始序列号

- 为什么不是四次？

  因为服务端在三次握手过后，双方的序列号已经确定了，无需额外的第四次。

##### 5.TCP四次挥手

- 关闭方先发送关闭请求过来，然后进入关闭1状态
- 被动关闭方收到关闭请求，返回关闭响应，进入等待关闭状态
- 被动关闭方再把未传输完信息发送过去，主动放收到之后进入手动关闭状态
- 关闭方发送正式关闭响应

### Netty

##### 1.Netty 是什么？

Netty是基于nio的一个网络通信框架，它封装了jdk的nio，让我们可以方便的使用nio来处理连接。 并且保持了一个高并发下的高性能。它实现高性能的核心是它背后的I/O模型和线程模型

首先它的I/O模型采用的是高性能epoll/select 模型，是一个IO多路复用模型 NIO，由selector来管理多个连接是否准备就绪

I/O多路复用模型有三种：

- select ：每次都遍历文件描述符（与远程传输的抽象符号）来查询哪些已经传输完毕了，用数组来存储文件描述符。 有连接数量的限制

- poll：每次都遍历文件描述符（与远程传输的抽象符号）来查询哪些已经传输完毕了，用链表来存储文件描述符。  没有数量的限制

- epoll：通过回调的方式来触发数据接收。无需遍历。减少了遍历的时间并且可以没有连接数量的限制

它的线程采用的是Reator模型

主要有两个线程池，boss线程池和worker线程池。boss线程池负责注册连接到selecter上并且监听是否已完成连接，如果已经是完成连接则将channel注册到worker线程池。从中选取一个NioEventLoo注册，当IO可读的时候就进行读写

##### 2.粘包和拆包问题

拆包：一个完整的应用包可能会被 TCP 拆分成多个包进行发送。

粘包：也可能把小应用包的封装成一个大的 TCP数据包发送。

消息头指定好消息体的长度，在channel中读取的时候进行长度的判断

##### 3.netty默认启动的线程数

Netty的默认启动了电脑可用线程数的两倍，在调用了bind方法的时候执行。

##### 4.netty channel有消息了如何分发到对应的线程执行？

channel中有引用指向对应的NioEventLoop来让其执行。

### 工作

##### 1.你们们持久化是异步的，那么怎么保证数据不丢失呢？

> 异步的持久化，只有持久化成功才会给该实体类对象标记上已更新，等下一次定时入库或者停服入库的时候会遍历内存仲未更新的对象继续入库。

##### 3.线程模型？ 

> 账号对应线程池。hashPool
>
> 创建的线程池中每条线程有自己独立的任务队列，然后根据账号的不同将任务提交到不同的线程的任务队列中。
>
> 账号对应队列。forkJoinPool
>
> 创建线程池，和一个任务队列的集合，根据账号的不同把任务分发到不同的任务队列中，而线程池是自动获取任务队列集合中的进行消费。因为每执行完一个任务才从任务队列中移除该任务，

##### 4.协议包解析请求分发

> 自定义的协议包里面包括了 包头、协议号、长度和byte数组的数据部分。 包头里面传输特定密钥，保证传输的完全性，长度用于解决粘包和拆包的问题，协议号用于进行分发请求，byte数组就是数据部分
>
> 分发请求的处理：自定义注解 ，在每个controller的方法体上加该注解，并且加上协议号。在Sping容器启动完成后扫描所有Bean，将标示了该注解的方法 缓存起来，用协议号和方法缓存起来，后续分发的时候根据协议号直接调用该方法。方法需要统一参数。

##### 4.事件机制

> 简单来说就是通过自定义注解的方式，在定义一个通用的处理事件的Manager类，在Spring容器启动完成后扫描所有的bean，将监听事件的方法用事件class与方法集合存储起来，提供方法抛出事件，然后执行所有的监听方法。

##### 5.缓存机制

> 底层使用的是GUAVA cache的框架，缓存过期的时间是30分钟，也是通过自定义注解的形式来实现，定义manager来管理所有的入库的实例，主要的查询数据库的地方有 在查询缓存中没有的时候，在玩家第一次登陆的时候加载玩家数据。

##### 6.配置加载机制

> 读取到配置文件，按照一定的格式对文件内容进行解析，将内容封装到javaBean里面，然后放入集合中，利用自定义注解 注入到每个标示了该注解的成员变量上

##### 7. 排行榜的实现？

> 猜测是使用链表的结构来实现，根据值来上下的浮动。

##### 6.消息队列出现积压情况？

>  出现了积压那就是消费者出现了问题嘛，首先得恢复消费者。

##### 8.ProtoBuf可以二进制传输，那说说Java对象的序列化，它有什么特点，序列化UID又是什么?
> java对象的序列化的特点是他可以让一个对象跨越不同的jvm虚拟机来进行传输。得到属性相同的对象。每个需要序列化的对象类都需要实现**Serializable**接口。这个接口是一个标识的作用。序列化UID是为了保证反序列化回来的对象和与之对应的java类是同一个版本的



##### 9.CSRF攻击原理与解决方法？



##### 10.#{}和${}的区别是什么?

\#{}是预编译处理，${}是字符串替换。

Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的set 方法来赋值；

Mybatis 在处理${}时，就是把${}替换成变量的值。

使用#{}可以有效的防止 SQL 注入，提高系统安全性

##### 11.联盟模块的实现原理

采用锁的方式实现，成员变化需要锁住整个联盟的对象，成员变量采用并发安全的集合等，读的时候直接访问，不需要上锁来访问，保证若一致性即可。

##### 12.圣物模块

类似于一套装备系统，属性树的原理：编写对应的树的分支，定义好每个节点的类型-就是class的类型

##### 13.战斗模块

lua战斗服。

战斗的校验：前端发起战斗请求，后段存储战斗id以及对应的BattleInfo（teamInfo）。前端打完后将BattleResult返回，然后对于战斗id相同且胜利的战斗进行校验，主要是用存储的battleInfo去跑一遍战斗。

### spring cloud

##### 1.微服务？

##### 2.Spring Could的各个组件？ 

### 消息队列RabbitMQ

##### 1.RabbitMQ是什么？

>  RabbitMQ是一个消息中间件，

##### 2.AMQP模型的几大组件？

> - 交换器 (Exchange)：消息代理服务器中用于把消息路由到队列的组件。
> - 队列 (Queue)：用来存储消息的数据结构，位于硬盘或内存中。
> - 绑定 (Binding)：一套规则，告知交换器消息应该将消息投递给哪个队列。

##### 3.说说生产者Producer和消费者Consumer?

> 生产者就是负责生产消息，消费者就是负责消费消息的。

##### 4.为什么需要消息队列？

##### 5.说说Broker服务节点、Queue队列、Exchange交换器？

> Broker服务器节点就相当于一个MQ实例，里面可以有很多的队列和很多的交换器
>
> Queue队列就是存储消息的队列，与交换机绑定，由交换机分发消息到对应的队列中
>
> 交换器就是将生产者下发的消息根据绑定的规则分发到不同的队列中。

##### 6.什么是RoutingKey路由键？

> RabbitMQ的分发消息的依据是 先分发到路由上，再根据路由key来分发到不同的队列中

##### 8.如何保证消息的可靠性？

- confirm 确认模式

> 消息从生产者到交换机的时候会返回一个confirmCallback
>
> 可以知道消息是否成功的分发到我们的交换机
>
> spring.rabbitmq.publisher-confirm-type=correlate

- return 退回模式

> 当消息从生产者成功交换到交换机，再从交换机到队列路由失败时才会执行returnCallback 
>
> 可以知道消息是否成功的分发到我们的队列中

##### 9.交换器4种类型？

- Fanout：广播,发送消息到每一个与之绑定的队列
- Direct：定向
- Topic：通配符方式，
- Headers: 通过headers属性来分配

##### 10.生产者消息运转？

##### 11.消费者接收消息过程？

##### 12.死信队列？导致死信的即中原因

**死信队列：**

当消息成为Dead Message后，可以被重新发送到另外一个交换机，这个交换机就是DLX，由这个交换机可以分发到的队列就叫作死信队列。

**死信的原因：**

- 队列消息达到限制
- 消费者拒绝接受消费信息，
- 队列存在消息过期设置，或者是消息已达到过期时间

##### 13.延迟队列，如何实现

通过设置队列中信息的过期时间，然后绑定好对应的死信队列就可以实现。

##### 14.发送确认机制

生产者发送消息到交换机的时候，会返回一个comfirm回调方法。可以确认消息是否成功到达交换机

##### 15.生产者如何将消息可靠投递到MQ？

- Client发送消息给MQ

- MQ将消息持久化后，发送Ack消息给Client，此处有可能因为网络问题导致Ack消息无法发送到Client，那么Client在等待超时后，会重传消息；

### 面筋

##### 1.讲一下ArrayList和LinkList的区别？使用场景？

>  ArrayList的底层实现是数组的形式，而LInklist的底层实现是链表的形式，ArrayLIst由于数组，数组的长度是需要固定的，长度不一定等于容器的长度，会有内存的浪费，但是由于是数组的形式可以通过下标来访问所以访问快， 而ArrayList的话则是元素的数量等于链表实际消耗的内存大小，节省内存，但是访问的话就需要遍历的方式来访问某个元，比较耗时。对于需要频繁的访问的建议使用ArrayList，如果是数据量大且不需要根据下标来访问的话使用LinkLIst比较好，不会有太多的内存浪费

##### 2.ArrayList插入的逻辑？答：讲了点扩容的东西

> 插入的话会判断是否达到容器的扩容阈值，如果达到则会申请更大的内存空间，然后把旧数组的内容copy过去。

#####  3. LinkList做聊天记录的存储的话，如果是定长的，有什么数据结构可以更好的替代吗？

> 首先，聊天记录的话最需要的是按照下标多少到多少来进行获取和遍历，所以最好的还是通过数组的形式来进行代替，并且是定长的话就不存在随着纪录的增多，数组扩容造成大量的空间浪费。并且数组在大数据的情况下遍历的速度比较快

##### 4.两种List遍历全部谁快，原理？答：

>  ArrayList，因为地址是连续的，然后取的时候不用通过拿去下一个引用的地址去查找。直接就可以计算访问

##### 5.HashMap和TreeMap的区别？

> 底层的数据结构不一样，HashMap的底层是数组+链表或者红黑树的形式。TreeMap的底层实现就是红黑树，HashMap的存储是无序的，而TreeMap的存储是有序。

##### 6.HashMap如果发生hash碰撞怎么办？

> 如果发生的hash碰撞，那么会用链表的形式存储起来，即同一个hash key指向一个链表，其中存放着hash冲突的value，然后用equal方法查找相同的key  

##### 7.HashMap底层的构造是什么样子？

> HashMap的底层是数组+链表的形式，特殊情况则会存在红黑树的结构

##### 8. 虚拟机里面有几种结构？

> 程序计数器 用于执行记录指令的编号
>
> 堆 存储对象的地方
>
> 栈 存储方法执行的内存模型
>
> 虚拟机栈 存储本地方法执行的内存模型
>
> 方法区 存储 类信息、静态常量的地方

##### 9.堆的内存大小如何分配？答：主要讲了几个设置的参数。

> 堆大小，我们可以控制的是整个堆的大小，还可以控制新生代、老年代的大小。都可以通过参数进行控制
> -Xms：初始堆得得大小
> -Xmx:最大堆大小
> -XX:NewSize：设置年轻代大小
> -XX:NewRatio：设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1:3
> -XX:SurvivorRatio: 年轻代中Eden区与两个Survivor区的比值。
> 注意Survivor区有两个。如：3，表示Eden：Survivor=3:2，一个Survivor区占整个年轻代的1/5
##### 10. 问了垃圾回收器的搭配？答：讲了CMS+ParNew的组合还有G1收集器，说项目用的G1

##### 11.G1的特性，优缺点。答：照着JVM来说

- 可通过参数来控制控制的停顿时间

G1会把内存分成一块一块，并且每一块内存都是有新生代老年代之分，新生代就分为Eden和Suervier。然后每块内存也是有优先级别的用队列来维持，根据预留的停顿时间来先回收优先级别高的内存块


每个分区都存放在一个优先队列里面，优先回收级别高的内存块，（回收级别高-回收的时候收益最高的分区），可以设置期望最大停顿时间的参数等.
物理分区，逻辑上再分分新生代和老年代

##### 12.G1什么时候进行Young GC？答：分配内存时，内存不够的时候...（感觉说了废话），然后说了一下G1没有那么强的分代概念，会回收收益高的Regi on,可以设置期望最大停顿时间的参数等.

> 在创建新对象的时候，发现新生代的内存不足以支持该对象的创建，或者新生代对象创建后达到了阈值，就会进行Young GC
> 
> 空间压缩：G1采用复制-整理算法，在压缩空间方面有优势，可以避免产生内存空间碎片；而CMS采用标记-清除算法，会产生较多的空间碎片。
> 内存模型方面：G1采用物理分区（Region），逻辑分代，Eden、Survivor、Old区不在是连续的一整块内存
> ，而是由不连续的内存区域（Region）组成；而CMS中Eden、Survivor、Old区是连续的一整块内存。 G1既可以收集年轻代，也可以收集老年代；而CMS只能收集老年代。
##### 13.Volatile的用法，有什么优点，能不能并发修改，比如用在整形上？答：从工作内存和主内存讲解，原理，还有不能并发修改的原因。

> 首先jvm的内存结构就是每个线程都有自己的工作内存，其中工作内存中的变量都与主内存的相等，而Volatile的作用就是为了保证工作内存中的变量与主内存中的变量保持一致，即某个变量被volatile修饰，当主内存中变量发生变化后，某个线程在读取该变量的时候发现版本不一致，会获取主内存中最新的变量。
>
> 不能保证并发修改安全，因为读取的时候保证是一致的，但是读取和修改并不是原子性的操作，比如两个线程同时的进行读取，然后修改，79->80, 两个现场都给该值+1，预想记过是81，但可能会出现是80的情况。

##### 14. ClassLoader的机制？答：7个阶段，还有双亲委派机制的内容。
1、加载 读取类文件，生成class类对象
2、验证 验证class文件的安全性
3、准备 为类申请内存空间
4、解析 将引用变量替换为直接引用
5、初始化 执行静态变量初始化和静态代码 优先执行父类
6、使用 正常调用
7、销毁 gg 

双亲委托机制，加载一个类的时候会先最底层的classloader的路径寻找，找不到再在其父类加载器的路径上寻找

启动类加载器
拓展类加载器
应用类加载器

##### 15.设计一款自己的ClassLoader，有什么用法？答：继承，然后实现loadClass()方法。
继承应用类加载器，然后实现loadClass方法

##### 16.New了两个一模一样的ClassLoader，去load同一个class文件，load进来的类会相等吗？

答：不相等，比较两个对象是否相等有个就是比较是否同一个构造器，不是同一个则不相等。

 

##### 17.那这两个会共享一份加载类缓存吗？答：不会，因为是不同的构造器对象，每个有自己的一份缓存..后面再问缓存相关的就不懂了...

##### 18.根据ClassLoader讲解热更机制？答：讲了JVMTI还有Java Instrumentation API的原理，还有agent，还有自己项目的情况。

##### 19.如果设计一款自己的ClassLoader，想修改线上的方法类参数，怎么设计？答：讲解了热更不能新增删除方法，也不能更改方法的参数之类的，但对方还是追问如果想呢？我就讲了别的方案，但对方说就是想加参数，直接说不会。

##### 20.用wait/notify实现生产者消费者？

首先就是生产的代码和消费的代码都需要上锁，然后锁里面 生产者先判断库存是否已满，满了就调用wait方法，如果生产就调用notify唤醒消费者。 而消费者进行消费，如果库存不足则使用wait，消耗完库存就调用notify唤醒生产者。
库存变量a
锁：b

生产者： 拿b锁，判断库存是否满了，满了wait,不满则+库存然后释放锁
消费者：循环拿b锁，判断库存是否大于0，是则消费-库存，释放锁并且notify所有的生产者

##### 21.如果消费者阻塞太久怎么办？答：可以用wait(time)，对方说还是太久呢?感觉是坑，这套机制本来消费者没有消息过来就是得阻塞。

##### 22.netty参数 ，netty是基于0拷贝，内核直接copy的所以速度快，那么这块0拷贝的内存大小设置多少合适
感觉问的是高低水位
netty如果达到的了高水位，则可以判断channel是否可读
恢复到低水位则通道继续可读

对于高吞吐量场景（如文件传输、视频流），可以适当提高高低水位值。 让其写入一部分，再处理
对于低延迟场景（如实时通信），应降低高低水位值，以减少延迟。    及时处理
综合来说要高水位得大于协议包的大小
##### 24.跨服系统的架构

中央服，在中央服里面写跨服逻辑，通过rpc

##### 25.死锁是如何产生？ 如何解决死锁？ 乐观锁 悲观锁
两个线程都需要两个锁，并且取锁的顺序不一致，

乐观锁：cms
悲观锁：直接上锁

可重入锁：

允许同一个线程多次获取同一把锁。
当一个线程已经持有锁时，它可以再次请求获取同一把锁，而不会导致死锁或其他问题。
可重入锁也被称为递归锁，因为同一线程的外层函数获得锁之后，内层递归函数仍然可以获取该锁，而不会影响到外层函数的执行。
不可重入锁：

只判断锁是否已经被其他线程持有，如果已经被持有，则申请锁的线程会被要求等待。
实现起来较为简单，因为它不需要考虑锁的重入机制。

##### 26.java四大引用
强引用：我们new一个对象就是强引用
软引用：内存足够的时候软引用是不会被回收的，内存不足的时候软引用则会被回收
弱引用：无论内存是否足够，只要进行了垃圾回收就会进行回收
虚引用：随时可能会被回收

##### 27.如何实现分布式锁
实现分布式锁一般都是需要中间件的支持
基于redis实现分布式锁
对于redis中的设置该值，设置成功则代表上锁成功，设置失败则代表上锁失败，并且需要再final 进行锁的取消 即删除该值


##### 29.如何保证Rpc的准确性，幂等性
首先接口的调用都会在同一个线程执行，然后只需要做好逻辑判断就可以方式多次发送的问题。

如果是例如充值的，一般会创建号订单号，每次都会根据这个订单号来检查对应的信息，防止幂等性。

##### 30.Netty的网络模型
Netty采用的是基于NIO的异步事件驱动模型，主要由三个核心组件构成：事件循环器（EventLoop）、通道（Channel）、处理器（Handler）。

1.事件循环器（EventLoop）

事件循环器是Netty网络模型的核心组件，负责循环监听I/O事件、处理任务、调度事件等。在Netty中，每个事件循环器都是独立的线程，可以运行在单独的线程、线程池或者主线程中。

2.通道（Channel）

通道是Netty中连接客户端和服务器的基本组件，它代表一个打开的连接，可以进行数据读写操作。Netty提供了各种类型的通道，如用于TCP协议的NioSocketChannel、用于UDP协议的NioDatagramChannel等。

3.处理器（Handler）

处理器是Netty网络模型中的数据处理单元，可以处理通道的读写事件和业务逻辑事件等。Netty中提供了很多种不同类型的处理器，如编码解码器、处理器聚合器、HTTP处理器等。用户可以通过自定义处理器来实现自己的业务逻辑。


有两个线程池：boss线程池和worker线程池
boss线程池负责与客户端建立链接，当有客户端链接到的时候，会生成一个socketchannel注册到worker线程池中
worker线程池则通过轮询注册在其身上的socketchannel，如果有读写事件，就进行io的读写，读写到bytebuf这个字节容器中，最后再丢到我们自己定义的handler来就行逻辑处理
##### 31.联盟模块是如何实现？
分为：
联盟信息（公共的）
个人联盟信息
当需要修改联盟信息的时候，需要进行上锁，由于我们的联盟这个db是放到缓存里面的，联盟信息里面又有许多其他信息，例如人数、联盟贡献度、联盟经验之类的。
当一个玩家需要退出联盟的时候，会扣除联盟贡献度、联盟经验值，这时候需要对于贡献度和经验值进行上锁。   这里需要用到锁链，锁链的意义是对两个锁进行排序，每次拿锁和释放锁都是按照唯一顺序来进行。这样子就可以避免死锁的情况。

##### 32.任务模块是如何实现的？
任务的基本组成的要素：条件类型，触发条件
每个条件类型都对应一个处理器。这个处理器再触发任务进度更改的时候会调用，会获取玩家的任务数据，然后根据处理器的逻辑来对任务进度修改并且保存
触发条件则是控制任务是否生效是否显示
一般的触发条件是 等级，是否在某活动中
这里需要对每种触发条件进行监听，然后进行任务的触发。

##### 33.zookeeper的详情？为啥要用zookeeper？
提供类似于linux系统上的文件的节点。每个节点都可以有下一级等。可以很方便的管理逻辑。因为设计思想参考了dubbo，dubbo也是用的zookeeper就用了zookeeper。

##### 34.说下反射的过程，反射是如何使用？
通过class.forName获取类对象，然后根据类对象可以获取其成员变量，方法。然后通过反射 传入obj和参数即可调用方法。



##### 35. 热更代码

以下情况不能热更：
- 新增方法
- 方法体增加参数
- 增加、删除成员变量
- 增加、删除匿名内部类

##### 36. 架构
游戏服：单进程一把梭
1)由于登录一般需要跟第三方平台对接,走http请求,一般100ms处理一个，所以单线程情况下1秒处理10个，登录效率有点低，所以优化出登陆服

登录服、游戏服：与第三方对接登录逻辑抽取出来。 游戏服只负责游戏逻辑。

##### 37.Netty参数
1）channel 能用Linux epoll机制  不能就Java NIO
2）childOption(ChannelOption.TCP_NODELAY, true) 禁用Nagle算法   实时发送不管包大小，直接来多少发多少 不合并发
3）childOption(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(16 * IOUtils.BYTES_PER_KB, 16 * IOUtils.BYTES_PER_MB))

逻辑->write->netty缓冲区->flush->TCP缓冲区

如果数据量超过了设置的高水位值，就设置通道Channel不可写状态。
如果Netty缓冲区的数据量低于低水位值时，就设置通过Channel可写状态。
Netty默认设置的高水位为64KB，低水位为32KB。

发送数据的时候需要判断channel是否可写



##### RPC如何实现
RPC核心点：1、服务的注册与发现 2、消费服务时的负载均衡 3、RPC数据返回的处理
1、通过zookeeper，启动服务器把自己提供的服务和 消费什么服务注册上去
2、消费服务的时候，根据负载均衡策略来选择对应的服务（指定服务器id消费、随机消费等）
3、RPC数据返回则通过编号对应ComputeFuture回调。数据返回的时候根据编号来获取对应回调执行即可。
##### ORM框架
ORM框架的核心点：1、实体类的映射 2、常见增删查改的操作 3、数据的缓存以及持久化
1、通过自定义注解标记出主键等信息，启服自动见表
2、封装方法即可
3、第三方缓存guava缓存，并且异步线程池入库，对象身上有是否已更新标识。
##### 事件系统
事件框架的核心：1、同步、异步的方式 2、通过注解就可以简单使用
1、通过线程池取模方式
2、自定义监听事件注解，读取该方法的参数（事件实体类）即可分类。再好对事件进行分类处理
##### 任务模块 
任务条件枚举：
定义各种任务条件,对不同条件进行处理
任务类型枚举：
定义各种任务类型（主线、成就、普通任务、可重复完成任务），对于任务的更新、完成、是否触发下个任务、完成任务
任务分组枚举：
各个模块的任务初始化逻辑
##### 活动模块
核心点：1、 活动的生命周期：预开启阶段、开启阶段、展示阶段、结束关闭    
2、结算时刻需要对在线玩家和非在线玩家分开处理。并且删除活动数据


##### 如何排查线上问题
1、先看进程是否正常运行
2、再看日志是否有报错
3、jmap工具查看java内存情况
4、jstack 查看java线程情况

##### dubbo框架
底层使用netty
dubbo默认线程池大小是200.

##### TCP&UDP&WebSocket&HTTP&自定义应用层
### WebSocket：
> 属于应用层的协议，WebSocket 服务器需要处理 HTTP 请求，因为 WebSocket 的握手过程是通过 HTTP 协议完成的。首先进行tcp三次握手，然后客户端发送一个http请求升级为websocket链接。服务端同意返回响应。即握手成功。
握手成功后，连接会从 HTTP 协议升级为 WebSocket 协议，后续通信不再使用 HTTP。

WebSocket 协议的数据传输是通过 帧（Frame） 的形式进行的。 
fin：是否最后一帧
mask：是否掩码 
masking key：解码key
Opcode：帧类型
len：长度
data：数据
### Http：
> 属于应用层的协议，通过tcp进行三次握手，建立tcp链接 随后进行http通信。

### TCP：
TCP是面向流的协议，数据以字节流的形式传输，没有明确的边界。
为什么会出现沾包：
1、TCP有两个缓冲区：发送缓冲区、接收缓冲区，两个区域都可能将会将多个小包合并成一个打包进行发送，
2、Nagle算法：会将多个小包合并成为一个较大数据包发送（一般游戏需要禁用，实时性）

### UDP
不需要建立连接，数据以数据报的形式传输，每个数据都有明确的边界。
##### Netty
  

##### 数据库分区表 分表 分库  SQl优化 索引设计
分区表：
分区表是将一张大表按某种规则（如范围、列表、哈希等）划分为多个逻辑部分的技术。每个分区可以独立存储和管理，但对用户透明，查询时仍像操作一张表。
比如游戏里面进行分区表的话通常是运营日志：按照时间区间、操作类型分表
（提升的是查询的性能，适合用于频繁查询）
分表：分表是将一张大表拆分为多个小表，每个小表存储部分数据。分表通常需要应用层支持，查询时需要明确操作哪张表。
（其实就是将数据分散到不同表 防止单表的数据过大）
分库：水平分库：游戏里面的话就是不同服的玩家数据是不同库 垂直分库：玩家数据、运营数据存储再不同数据库

使用ShardingSphere框架来进行分区分表。
通过配置不同的数据源来进行分库的操作，配置好表的分表规则（例如id求余）来进行分表，然后java内就调用该connet来查询即可

索引设计：
单个索引：1、选择合适的列：例如年龄，反面例子性别
复合索引：1、最左前缀原则，将选择性大的放前面 2、覆盖索引：查询的值都在索引中就可以直接在索引获取数据3、符合索引可以优化order by group by操作


##### 事务的基本特征
原子性：事务中的所有操作要么全部成功，要么全部失败。
一致性：事务执行前后，数据库的状态必须保持一致。
隔离性：多个事务并发执行时，一个事务的操作不应影响其他事务。
持久性：事务一旦提交，对数据库的修改就是永久性的。
##### mybatis设计
基本使用：
resouces：通过编写mapper.xml文件编写指定的sql语句
entity：与数据库对应的实体类
mapper：编写对应的mapper接口，编写方法对应指定的sql语句绑定
提供了一级缓存和二级缓存的机制。
一级缓存：同一个sqlSession执行相同的SQL语句会缓存结果，每次查询都会新建一个sqlSession
二级缓存：它是 Mapper 级别的缓存，多个 SqlSession 可以共享同一个 Mapper 的缓存。

SqlSession代表了与数据库的一次会话
SqlSession的生命周期：
1、同一个事务中会复用同一个sqlSession
2、非事务方法每次调用都会开启一个新的sqlSession

事务的管理依赖于@Transactional
##### JWT
Jwt结构：
Header头部：令牌类型和签名算法
Payload负载：数据
Signature签名：

服务器不需要存储会话信息。适合分布式系统和微服务架构

##### Session
会话，用户访问web服务端会为其创建一个httpSession,该Session每次都会通过cookie和url方式返回给客户端

##### 跨域问题
同源策略（Same-Origin Policy）的一种安全机制，用于限制从一个源（Origin）加载的网页脚本与另一个源的资源进行交互。跨域问题通常发生在前端（浏览器）与后端（服务器）分离的 Web 应用中，当前端尝试从不同源的服务器请求资源时，浏览器会阻止这种请求，除非服务器明确允许。

如何解决？
1、通过 Nginx 或 Apache 等反向代理服务器，将前端和后端的请求统一转发到同一个域名下，从而避免跨域问题。

2、服务端设置CORS策略，浏览器遇到跨域访问，会询问服务端是否允许跨域。服务端此时就可以给与允许什么进行访问
##### WebSocket

##### docker
镜像：环境+服务打包
容器：运行中的服务

编写dockerfile
两种打包方式
1、springboot 打出jar包，然后直接在dockerfile里面 指定所需环境jdk，mysql  mysql等 一般需要编写脚本来启动
2、指定maven环境 在docker中打包 并且运行

目录挂载

容器间通信
通过创建网络块来区分，不同服务可以在相同网络块中相互访问


docker compose
某个服务需要用到两个容器，则可以编写docker-compose.yml。 将多个服务编写出来
##### RestFul

##### Dubbo框架























